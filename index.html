<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Eisenhower Matrix</title>
<style>
  * { box-sizing: border-box; font-family: Arial, sans-serif; }

  body { margin: 0; padding: 20px; background: #f5f5f5; }

  .header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 20px;
  }

  h1 { margin: 0; flex: 1; }

  .add-btn {
    padding: 10px 14px;
    border: none;
    border-radius: 8px;
    background: #1976d2;
    color: white;
    cursor: pointer;
    font-size: 14px;
  }

  .add-btn.secondary { background: #6a1b9a; }

  .matrix {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr 1fr;
    gap: 15px;
    height: 80vh;
  }

  .quadrant {
    background: #ffffff;
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
  }

  .quadrant h2 { margin: 0 0 10px; font-size: 18px; }

  /* Group styles */
  .group-container {
    border: 1px solid #ccc;
    border-radius: 10px;
    margin-bottom: 10px;
    background: #fafafa;
    padding: 5px;
    cursor: grab;
  }

  .group-container.dragging { opacity: 0.5; }

  .group-header {
    font-weight: bold;
    padding: 6px 10px;
    border-radius: 8px;
    color: white;
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 6px;
    cursor: grab;
  }

  .group-header-left {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .group-menu {
    position: relative;
  }

  .group-dots {
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
    color: white;
    opacity: 0.8;
  }

  .group-dots:hover {
    opacity: 1;
  }

  .group-menu-content {
    display: none;
    position: absolute;
    right: 0;
    top: 18px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    overflow: hidden;
    z-index: 20;
    color: #333;
  }

  .group-menu-content div {
    padding: 6px 10px;
    cursor: pointer;
    white-space: nowrap;
  }

  .group-menu-content div:hover { 
    background: #eee; 
  }

  .group-content {
    padding-left: 15px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    min-height: 10px;
  }

  /* Nested groups visual indent */
  .group-content > .group-container {
    margin-left: 10px;
  }

  .task {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: #f1f1f1;
    padding: 8px 10px;
    border-radius: 6px;
    font-size: 14px;
    cursor: grab;
  }

  .task.dragging { opacity: 0.5; }

  .task-left {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .group-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
  }

  .task-menu { position: relative; }

  .dots {
    cursor: pointer;
    padding: 0 5px;
    font-weight: bold;
  }

  .menu {
    display: none;
    position: absolute;
    right: 0;
    top: 18px;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    overflow: hidden;
    z-index: 10;
  }

  .menu div {
    padding: 6px 10px;
    cursor: pointer;
    white-space: nowrap;
  }

  .menu div:hover { background: #eee; }

  .q1 { border-left: 6px solid #e53935; }
  .q2 { border-left: 6px solid #43a047; }
  .q3 { border-left: 6px solid #fb8c00; }
  .q4 { border-left: 6px solid #757575; }

  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 1000;
  }

  .modal-content {
    background: white;
    padding: 20px;
    border-radius: 12px;
    width: 320px;
    max-width: 90%;
  }

  label { display: block; margin: 8px 0; font-size: 14px; }

  .modal-actions {
    margin-top: 15px;
    display: flex;
    justify-content: flex-end;
    gap: 10px;
  }

  .delete-group-actions {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .delete-group-btn {
    padding: 8px;
    border: none;
    border-radius: 6px;
    background: #d32f2f;
    color: white;
    cursor: pointer;
    font-size: 14px;
  }

  .delete-group-btn:hover {
    background: #b71c1c;
  }

  .clear-data-btn {
    padding: 8px 12px;
    border: 1px solid #d32f2f;
    border-radius: 6px;
    background: white;
    color: #d32f2f;
    cursor: pointer;
    font-size: 12px;
  }

  .clear-data-btn:hover {
    background: #ffebee;
  }

  .sync-container {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-left: auto;
  }
  
  .sync-status {
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    background: #f0f0f0;
    color: #666;
  }
  
  .sync-status.syncing {
    background: #fff3cd;
    color: #856404;
  }
  
  .sync-status.online {
    background: #d4edda;
    color: #155724;
  }
  
  .sync-status.offline {
    background: #f8d7da;
    color: #721c24;
  }
  
  .google-drive-btn {
    padding: 8px 12px;
    border: none;
    border-radius: 6px;
    background: #4285F4;
    color: white;
    cursor: pointer;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 5px;
  }
  
  .google-drive-btn:hover {
    background: #3367D6;
  }
  
  .google-drive-btn.signed-in {
    background: #34A853;
  }
  
  .user-info {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-left: 10px;
  }
  
  .user-avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
  }
  
  .sync-options {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    background: white;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    padding: 10px;
    z-index: 100;
    margin-top: 5px;
    min-width: 150px;
  }
  
  .sync-options.show {
    display: block;
  }
  
  .sync-options button {
    display: block;
    width: 100%;
    padding: 6px 10px;
    margin-bottom: 5px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    cursor: pointer;
    text-align: left;
  }
  
  .sync-options button:hover {
    background: #f5f5f5;
  }
  
  .sync-options hr {
    margin: 8px 0;
    border: none;
    border-top: 1px solid #eee;
  }
</style>
</head>
<body>

<div class="header">
  <h1>Eisenhower Matrix</h1>
  <div class="sync-container">
    <span class="sync-status" id="syncStatus">Offline</span>
    <div style="position: relative;">
      <button class="google-drive-btn" id="googleDriveBtn" onclick="toggleSyncOptions()">
        <span>G</span>
        <span id="driveBtnText">Sync with Drive</span>
      </button>
      <div class="sync-options" id="syncOptions">
        <div style="margin-bottom: 10px; font-weight: bold;">Google Drive Sync</div>
        <button onclick="signInWithGoogle()" id="signInBtn">Sign in with Google</button>
        <button onclick="signOutFromGoogle()" id="signOutBtn" style="display: none;">Sign out</button>
        <hr>
        <button onclick="forceSyncToDrive()">Sync Now</button>
        <button onclick="loadFromDrive()">Load from Drive</button>
      </div>
    </div>
    <div class="user-info" id="userInfo" style="display: none;">
      <img id="userAvatar" class="user-avatar" src="" alt="">
      <span id="userName"></span>
    </div>
    <button class="clear-data-btn" onclick="clearAllData()">Clear All</button>
    <button class="add-btn secondary" onclick="openGroupModal()">+ Add Group</button>
    <button class="add-btn" onclick="openTaskModal()">+ Add Task</button>
  </div>
</div>

<div class="matrix">
  <div class="quadrant q1" id="q1"><h2>Important &amp; Urgent</h2></div>
  <div class="quadrant q2" id="q2"><h2>Important &amp; Not Urgent</h2></div>
  <div class="quadrant q3" id="q3"><h2>Not Important &amp; Urgent</h2></div>
  <div class="quadrant q4" id="q4"><h2>Not Important &amp; Not Urgent</h2></div>
</div>

<div class="modal" id="taskModal">
  <div class="modal-content">
    <h3>Add / Edit Task</h3>
    <label>Task name <input id="taskName" style="width:100%"></label>
    <label><input type="checkbox" id="important"> Important</label>
    <label><input type="checkbox" id="urgent"> Urgent</label>
    <label>Group
      <select id="taskGroup" style="width:100%">
        <option value="">No Group</option>
      </select>
    </label>
    <div class="modal-actions">
      <button onclick="closeTaskModal()">Cancel</button>
      <button onclick="saveTask()">Save</button>
    </div>
  </div>
</div>

<div class="modal" id="groupModal">
  <div class="modal-content">
    <h3 id="groupModalTitle">Add Group</h3>
    <label>Group name <input id="groupName" style="width:100%"></label>
    <label>Group color <input type="color" id="groupColor"></label>
    <label>Parent group
      <select id="groupParent" style="width:100%">
        <option value="">No Parent</option>
      </select>
    </label>
    <div class="modal-actions">
      <button onclick="closeGroupModal()">Cancel</button>
      <button onclick="saveGroup()" id="saveGroupBtn">Add</button>
    </div>
  </div>
</div>

<div class="modal" id="deleteGroupModal">
  <div class="modal-content">
    <h3>Delete Group</h3>
    <p>Are you sure you want to delete the group "<span id="deleteGroupName"></span>"?</p>
    <div class="delete-group-actions">
      <label>
        <input type="radio" name="deleteOption" value="deleteTasks" checked> Delete all tasks in this group
      </label>
      <label>
        <input type="radio" name="deleteOption" value="keepTasks"> Keep tasks (they will become ungrouped)
      </label>
      <button class="delete-group-btn" onclick="confirmDeleteGroup()">Delete Group</button>
      <button onclick="closeDeleteGroupModal()">Cancel</button>
    </div>
  </div>
</div>

<script>
// ============================================
// CONFIGURATION - CHANGE THESE FOR YOUR SITE
// ============================================
const GOOGLE_CONFIG = {
  clientId: '929057304226-tl2paj30bdkim7hp7q16g86u55g4adgc.apps.googleusercontent.com',
  apiKey: 'AIzaSyDDGbG8N4Npk2ngM2R1GfZeoq4PRrs9MRE'
};

// ============================================
// APP STATE
// ============================================
const STORAGE_KEY = 'eisenhowerMatrixData';
const FILE_VERSION = '1.0';
const SYNC_FILE_NAME = 'eisenhower-matrix.json';

let groups = {};
let editingTask = null;
let editingGroup = null;
let deletingGroup = null;
let googleUser = null;
let syncInProgress = false;
let lastSyncTime = null;

// ============================================
// INITIALIZATION
// ============================================
function initGoogleAuth() {
  const gapiScript = document.createElement('script');
  gapiScript.src = 'https://apis.google.com/js/api.js';
  gapiScript.onload = () => {
    gapi.load('client', initGapiClient);
  };
  document.head.appendChild(gapiScript);

  const gisScript = document.createElement('script');
  gisScript.src = 'https://accounts.google.com/gsi/client';
  gisScript.onload = () => console.log('Google Identity Services loaded');
  document.head.appendChild(gisScript);
}

async function initGapiClient() {
  try {
    await gapi.client.init({
      apiKey: GOOGLE_CONFIG.apiKey,
      discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
    });

    const savedToken = localStorage.getItem('googleDriveToken');
    if (savedToken) {
      gapi.client.setToken(JSON.parse(savedToken));
      googleUser = JSON.parse(savedToken);
      updateAuthUI(true);
      loadUserInfo();
    }
  } catch (error) {
    console.error('Failed to initialize Google API:', error);
  }
}

// ============================================
// GOOGLE AUTH
// ============================================
async function signInWithGoogle() {
  if (!window.google || !window.google.accounts) {
    alert('Google sign-in not loaded. Please refresh the page.');
    return;
  }

  const tokenClient = google.accounts.oauth2.initTokenClient({
    client_id: GOOGLE_CONFIG.clientId,
    scope: 'https://www.googleapis.com/auth/drive.file',
    callback: async (response) => {
      if (response.error) {
        console.error('Sign-in error:', response);
        return;
      }

      gapi.client.setToken(response);
      localStorage.setItem('googleDriveToken', JSON.stringify(response));
      googleUser = response;
      updateAuthUI(true);
      await loadUserInfo();
      loadFromDrive();
    },
  });

  tokenClient.requestAccessToken({ prompt: 'consent' });
  closeSyncOptions();
}

function signOutFromGoogle() {
  if (googleUser) {
    google.accounts.oauth2.revoke(googleUser.access_token);
    gapi.client.setToken(null);
    localStorage.removeItem('googleDriveToken');
    localStorage.removeItem('googleUserInfo');
    googleUser = null;
    updateAuthUI(false);
    updateSyncStatus('Offline');
  }
  closeSyncOptions();
}

async function loadUserInfo() {
  try {
    const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
      headers: { 'Authorization': `Bearer ${googleUser.access_token}` }
    });

    if (response.ok) {
      const userInfo = await response.json();
      localStorage.setItem('googleUserInfo', JSON.stringify(userInfo));
      document.getElementById('userAvatar').src = userInfo.picture || '';
      document.getElementById('userName').textContent = userInfo.name || userInfo.email;
      document.getElementById('userInfo').style.display = 'flex';
    }
  } catch (error) {
    console.error('Error loading user info:', error);
  }
}

function updateAuthUI(isSignedIn) {
  if (isSignedIn) {
    document.getElementById('signInBtn').style.display = 'none';
    document.getElementById('signOutBtn').style.display = 'block';
    document.getElementById('googleDriveBtn').classList.add('signed-in');
    document.getElementById('driveBtnText').textContent = 'Synced';
    updateSyncStatus('Online');

    const savedUserInfo = localStorage.getItem('googleUserInfo');
    if (savedUserInfo) {
      const userInfo = JSON.parse(savedUserInfo);
      document.getElementById('userAvatar').src = userInfo.picture || '';
      document.getElementById('userName').textContent = userInfo.name || userInfo.email;
      document.getElementById('userInfo').style.display = 'flex';
    }
  } else {
    document.getElementById('signInBtn').style.display = 'block';
    document.getElementById('signOutBtn').style.display = 'none';
    document.getElementById('googleDriveBtn').classList.remove('signed-in');
    document.getElementById('driveBtnText').textContent = 'Sync with Drive';
    document.getElementById('userInfo').style.display = 'none';
    updateSyncStatus('Offline');
  }
}

// ============================================
// GOOGLE DRIVE SYNC
// ============================================
async function forceSyncToDrive() {
  if (!googleUser) {
    alert('Please sign in first');
    return;
  }

  if (syncInProgress) return;

  syncInProgress = true;
  updateSyncStatus('Syncing...');

  try {
    const matrixData = getCurrentMatrixData();
    const fileId = await findOrCreateDriveFile();
    await updateDriveFile(fileId, matrixData);

    lastSyncTime = new Date();
    localStorage.setItem('lastSyncTime', lastSyncTime.toISOString());
    updateSyncStatus(`Synced ${formatTime(lastSyncTime)}`);
  } catch (error) {
    console.error('Sync error:', error);
    updateSyncStatus('Sync failed');
  } finally {
    syncInProgress = false;
  }

  closeSyncOptions();
}

async function loadFromDrive() {
  if (!googleUser) {
    alert('Please sign in first');
    return;
  }

  if (syncInProgress) return;

  syncInProgress = true;
  updateSyncStatus('Loading...');

  try {
    const fileId = await findOrCreateDriveFile();
    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`, {
      headers: { 'Authorization': `Bearer ${googleUser.access_token}` }
    });

    if (response.ok) {
      const data = await response.json();
      if (confirm('Load data from Google Drive? This will replace your current matrix.')) {
        loadData(data);
        saveToStorage();
        updateSyncStatus('Loaded from Drive');
      }
    } else if (response.status === 404) {
      updateSyncStatus('No data in Drive');
    } else {
      throw new Error(`HTTP ${response.status}`);
    }
  } catch (error) {
    console.error('Load error:', error);
    alert('Failed to load from Google Drive');
    updateSyncStatus('Load failed');
  } finally {
    syncInProgress = false;
  }

  closeSyncOptions();
}

async function findOrCreateDriveFile() {
  try {
    const response = await gapi.client.drive.files.list({
      q: `name='${SYNC_FILE_NAME}' and trashed=false`,
      fields: 'files(id, name)',
      spaces: 'drive'
    });

    if (response.result.files.length > 0) {
      return response.result.files[0].id;
    }

    const createResponse = await gapi.client.drive.files.create({
      resource: { name: SYNC_FILE_NAME, mimeType: 'application/json' },
      fields: 'id'
    });

    return createResponse.result.id;
  } catch (error) {
    console.error('Error with Drive file:', error);
    throw error;
  }
}

async function updateDriveFile(fileId, data) {
  const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${googleUser.access_token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(data)
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}`);
  }

  return response.json();
}

// ============================================
// MATRIX CORE FUNCTIONS (NESTED GROUPS)
// ============================================

function safeEscapeSelector(value) {
  // Safe for querySelector / CSS selectors
  if (window.CSS && CSS.escape) return CSS.escape(String(value));
  // Fallback: prefix special chars with backslash
  return String(value).replace(/[^a-zA-Z0-9_-]/g, (ch) => '\\' + ch);
}

function getGroupContent(groupContainer) {
  return groupContainer.querySelector('.group-content');
}

function isInside(el, possibleAncestor) {
  return possibleAncestor && possibleAncestor.contains(el);
}

function getGroupChainFromElement(el) {
  // Returns group names from outermost -> innermost for the given element
  const chain = [];
  let currentGroup = el ? el.closest('.group-container') : null;
  while (currentGroup && currentGroup.classList.contains('group-container')) {
    chain.unshift(currentGroup.dataset.name);
    currentGroup = currentGroup.parentElement ? currentGroup.parentElement.closest('.group-container') : null;
  }
  return chain;
}

function ensureGroupChainInQuadrant(quadrantEl, chain) {
  // Ensures nested group containers exist (outer -> inner) and returns the innermost container
  let parentContainerEl = quadrantEl;
  let parentName = '';
  let currentContainer = null;

  chain.forEach(name => {
    const safe = safeEscapeSelector(name);
    let existing = parentContainerEl.querySelector(`:scope > .group-container[data-name="${safe}"]`);

    if (!existing) {
      existing = createGroupContainer(name, parentContainerEl, parentName);
    }

    existing.dataset.parent = parentName;
    currentContainer = existing;
    parentName = name;
    parentContainerEl = getGroupContent(existing);
  });

  return currentContainer;
}

function getGroupChainByName(groupName) {
  // Builds outer->...->groupName based on dataset.parent lookups.
  // This keeps membership stable across quadrants even if ancestors are missing in the target quadrant.
  const chain = [];
  const seen = new Set();
  let current = groupName;

  while (current && !seen.has(current)) {
    seen.add(current);
    chain.unshift(current);

    const safe = safeEscapeSelector(current);
    const inst = document.querySelector(`.group-container[data-name="${safe}"]`);
    const parent = inst ? (inst.dataset.parent || '') : '';

    current = parent;
  }

  return chain;
}

function cleanupEmptyGroupChain(startGroupContainer) {
  let current = startGroupContainer;
  while (current && current.classList && current.classList.contains('group-container')) {
    const content = getGroupContent(current);
    if (content && content.children.length === 0) {
      const parentGroup = current.parentElement.closest('.group-container');
      current.remove();
      current = parentGroup;
    } else {
      break;
    }
  }
}

function refreshTaskUI(taskEl) {
  const name = taskEl.dataset.name || '';
  const group = taskEl.dataset.group || '';
  const dotHtml = (group && groups[group]) ? `<span class="group-dot" style="background:${groups[group]}"></span>` : '';

  taskEl.innerHTML = `
    <div class="task-left">
      ${dotHtml}
      <span>${name}</span>
    </div>
    <div class="task-menu">
      <span class="dots">⋮</span>
      <div class="menu">
        <div onclick="openTaskModal(this.closest('.task'))">Edit</div>
        <div onclick="deleteTask(this.closest('.task'))">Delete</div>
      </div>
    </div>`;

  taskEl.querySelector('.dots').onclick = e => {
    e.stopPropagation();
    const menu = e.target.nextElementSibling;
    const isVisible = menu.style.display === 'block';
    document.querySelectorAll('.menu').forEach(m => m.style.display = 'none');
    document.querySelectorAll('.group-menu-content').forEach(m => m.style.display = 'none');
    menu.style.display = isVisible ? 'none' : 'block';
  };

  taskEl.addEventListener('dragstart', (e) => {
    e.stopPropagation();
    taskEl.classList.add('dragging');
  });

  taskEl.addEventListener('dragend', () => {
    taskEl.classList.remove('dragging');
    saveToStorage();
  });
}

function createTaskElement({ name, important, urgent, group }) {
  const task = document.createElement('div');
  task.className = 'task';
  task.draggable = true;
  task.dataset.name = name;
  task.dataset.important = String(!!important);
  task.dataset.urgent = String(!!urgent);
  task.dataset.group = group || '';
  refreshTaskUI(task);
  return task;
}

function ensureGroupContainerInScope(scopeEl, groupName) {
  const safe = safeEscapeSelector(groupName);
  let container = scopeEl.querySelector(`.group-container[data-name="${safe}"]`);
  if (!container) {
    container = createGroupContainer(groupName, scopeEl);
  }
  return container;
}

function getQuadrantFromImportantUrgent(isImportant, isUrgent) {
  return isImportant && isUrgent ? 'q1' : isImportant ? 'q2' : isUrgent ? 'q3' : 'q4';
}

// --- Serialization: save full nested layout ---
function serializeItems(containerEl) {
  const items = [];
  Array.from(containerEl.children).forEach(child => {
    if (child.classList.contains('task')) {
      items.push({
        type: 'task',
        name: child.dataset.name,
        important: child.dataset.important === 'true',
        urgent: child.dataset.urgent === 'true',
        group: child.dataset.group || ''
      });
    } else if (child.classList.contains('group-container')) {
      const groupName = child.dataset.name;
      const content = getGroupContent(child);
      items.push({
        type: 'group',
        name: groupName,
        children: content ? serializeItems(content) : []
      });
    }
  });
  return items;
}

function getCurrentMatrixData() {
  const layout = {};
  ['q1', 'q2', 'q3', 'q4'].forEach(qid => {
    const q = document.getElementById(qid);
    if (!q) return;

    const temp = document.createElement('div');
    Array.from(q.children).forEach(ch => {
      if (ch.tagName && ch.tagName.toLowerCase() === 'h2') return;
      temp.appendChild(ch.cloneNode(true));
    });

    layout[qid] = serializeItems(temp);
  });

  return {
    version: FILE_VERSION,
    timestamp: new Date().toISOString(),
    groups: { ...groups },
    layout
  };
}

function saveToStorage() {
  const data = getCurrentMatrixData();
  localStorage.setItem(STORAGE_KEY, JSON.stringify(data));

  if (googleUser && !syncInProgress) {
    clearTimeout(window.syncTimeout);
    window.syncTimeout = setTimeout(() => forceSyncToDrive(), 2000);
  }
}

function clearCurrentData() {
  document.querySelectorAll('.quadrant').forEach(q => {
    q.innerHTML = '<h2>' + q.querySelector('h2').textContent + '</h2>';
  });
}

function buildItemsInto(containerEl, items, parentGroupName = '') {
  items.forEach(item => {
    if (item.type === 'task') {
      const task = createTaskElement({
        name: item.name,
        important: item.important,
        urgent: item.urgent,
        group: parentGroupName || ''
      });
      containerEl.appendChild(task);
    } else if (item.type === 'group') {
      const groupContainer = createGroupContainer(item.name, containerEl, parentGroupName);
      const content = getGroupContent(groupContainer);
      buildItemsInto(content, item.children || [], item.name);
    }
  });
}

function loadData(data) {
  clearCurrentData();
  groups = data.groups || {};

  rebuildGroupSelects();

  // Backward compatibility: old format with data.tasks
  if (!data.layout && Array.isArray(data.tasks)) {
    data.tasks.forEach(t => {
      const quadrantEl = document.getElementById(t.quadrant);
      if (!quadrantEl) return;
      if (t.group && groups[t.group]) {
        const groupContainer = ensureGroupContainerInScope(quadrantEl, t.group);
        getGroupContent(groupContainer).appendChild(
          createTaskElement({ name: t.name, important: t.important, urgent: t.urgent, group: t.group })
        );
      } else {
        quadrantEl.appendChild(createTaskElement({ name: t.name, important: t.important, urgent: t.urgent, group: '' }));
      }
    });
    initGroupContainers();
    return;
  }

  // New format with nested layout
  const layout = data.layout || {};
  ['q1', 'q2', 'q3', 'q4'].forEach(qid => {
    const quadrantEl = document.getElementById(qid);
    if (!quadrantEl) return;
    buildItemsInto(quadrantEl, layout[qid] || [], '');
  });

  initGroupContainers();
}

// ============================================
// TASK FUNCTIONS
// ============================================
function openTaskModal(task = null) {
  editingTask = task;
  document.getElementById('taskModal').style.display = 'flex';

  if (!task) {
    document.getElementById('taskName').value = '';
    document.getElementById('important').checked = false;
    document.getElementById('urgent').checked = false;
    document.getElementById('taskGroup').value = '';
    return;
  }

  document.getElementById('taskName').value = task.dataset.name;
  document.getElementById('important').checked = task.dataset.important === 'true';
  document.getElementById('urgent').checked = task.dataset.urgent === 'true';
  document.getElementById('taskGroup').value = task.dataset.group || '';
}

function closeTaskModal() {
  editingTask = null;
  document.getElementById('taskModal').style.display = 'none';
}

function saveTask() {
  const name = document.getElementById('taskName').value.trim();
  if (!name) return;

  const isImportant = document.getElementById('important').checked;
  const isUrgent = document.getElementById('urgent').checked;
  const groupName = document.getElementById('taskGroup').value;

  const quadrantId = getQuadrantFromImportantUrgent(isImportant, isUrgent);
  const quadrantEl = document.getElementById(quadrantId);

  const taskEl = editingTask || document.createElement('div');
  taskEl.className = 'task';
  taskEl.draggable = true;
  taskEl.dataset.name = name;
  taskEl.dataset.important = String(isImportant);
  taskEl.dataset.urgent = String(isUrgent);

  // Remove from old parent, then re-place
  const oldGroupContainer = taskEl.closest('.group-container');

  if (groupName && groups[groupName]) {
    let groupContainer = quadrantEl.querySelector(`.group-container[data-name="${safeEscapeSelector(groupName)}"]`);
    if (!groupContainer) {
      groupContainer = createGroupContainer(groupName, quadrantEl, '');
    }
    taskEl.dataset.group = groupName;
    refreshTaskUI(taskEl);
    getGroupContent(groupContainer).appendChild(taskEl);
  } else {
    taskEl.dataset.group = '';
    refreshTaskUI(taskEl);
    quadrantEl.appendChild(taskEl);
  }

  if (oldGroupContainer) cleanupEmptyGroupChain(oldGroupContainer);

  saveToStorage();
  closeTaskModal();
}

function deleteTask(task) {
  const sourceGroup = task.closest('.group-container');
  task.remove();
  if (sourceGroup) cleanupEmptyGroupChain(sourceGroup);
  saveToStorage();
}

// ============================================
// GROUP FUNCTIONS
// ============================================
function createGroupContainer(groupName, parentContainerEl, parentGroupName = '') {
  const groupContainer = document.createElement('div');
  groupContainer.className = 'group-container';
  groupContainer.dataset.name = groupName;
  groupContainer.dataset.parent = parentGroupName || '';

  const color = groups[groupName] || '#1976d2';

  groupContainer.innerHTML = `
    <div class="group-header" style="background-color:${color}">
      <div class="group-header-left">
        <span>${groupName}</span>
      </div>
      <div class="group-menu">
        <span class="group-dots">⋮</span>
        <div class="group-menu-content">
          <div onclick="openEditGroupModal('${groupName}')">Edit Group</div>
          <div onclick="openDeleteGroupModal('${groupName}')">Delete Group</div>
        </div>
      </div>
    </div>
    <div class="group-content"></div>
  `;

  parentContainerEl.appendChild(groupContainer);

  setupGroupContainerDraggable(groupContainer);
  setupGroupMenu(groupContainer);
  setupDropTarget(getGroupContent(groupContainer), { type: 'group', groupName });

  return groupContainer;
}

function setupGroupContainerDraggable(groupContainer) {
  groupContainer.draggable = true;
  groupContainer.addEventListener('dragstart', (e) => {
    // Don't start drag from menus
    if (e.target.classList.contains('group-dots')) {
      e.preventDefault();
      return;
    }

    // DISABLED: dragging nested (child) groups.
    // Group nesting must be changed only via Edit Group.
    const hasParentGroup = !!(groupContainer.parentElement && groupContainer.parentElement.closest('.group-container'));
    if (hasParentGroup) {
      e.preventDefault();
      return;
    }

    e.stopPropagation();
    groupContainer.classList.add('dragging');
  });

  groupContainer.addEventListener('dragend', () => {
    groupContainer.classList.remove('dragging');
    saveToStorage();
  });
}

function setupGroupMenu(groupContainer) {
  const groupDots = groupContainer.querySelector('.group-dots');
  const groupMenu = groupContainer.querySelector('.group-menu-content');

  groupDots.addEventListener('click', (e) => {
    e.stopPropagation();
    const isVisible = groupMenu.style.display === 'block';
    document.querySelectorAll('.group-menu-content').forEach(m => m.style.display = 'none');
    document.querySelectorAll('.menu').forEach(m => m.style.display = 'none');
    groupMenu.style.display = isVisible ? 'none' : 'block';
  });
}

function initGroupContainers() {
  // Reattach group container handlers + make their contents droppable
  document.querySelectorAll('.group-container').forEach(groupContainer => {
    setupGroupContainerDraggable(groupContainer);
    setupGroupMenu(groupContainer);
    const content = getGroupContent(groupContainer);
    if (content) {
      const name = groupContainer.dataset.name;
      setupDropTarget(content, { type: 'group', groupName: name });
    }
  });
}

function rebuildGroupSelects() {
  const taskSelect = document.getElementById('taskGroup');
  if (taskSelect) {
    taskSelect.innerHTML = '<option value="">No Group</option>';
    Object.keys(groups).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      taskSelect.appendChild(opt);
    });
  }

  const parentSelect = document.getElementById('groupParent');
  if (parentSelect) {
    parentSelect.innerHTML = '<option value="">No Parent</option>';
    Object.keys(groups).forEach(name => {
      const opt = document.createElement('option');
      opt.value = name;
      opt.textContent = name;
      parentSelect.appendChild(opt);
    });
  }
}

function openGroupModal() {
  editingGroup = null;
  document.getElementById('groupModalTitle').textContent = 'Add Group';
  document.getElementById('groupName').value = '';
  document.getElementById('groupColor').value = '#1976d2';

  rebuildGroupSelects();
  const parentSel = document.getElementById('groupParent');
  if (parentSel) parentSel.value = '';

  document.getElementById('saveGroupBtn').textContent = 'Add';
  document.getElementById('groupModal').style.display = 'flex';
}

function closeGroupModal() {
  editingGroup = null;
  document.getElementById('groupModal').style.display = 'none';
}

function saveGroup() {
  const name = document.getElementById('groupName').value.trim();
  const color = document.getElementById('groupColor').value;
  const parentName = (document.getElementById('groupParent')?.value || '').trim();

  if (!name) return;

  if (parentName && parentName === name) {
    alert('A group cannot be a parent of itself.');
    return;
  }

  if (editingGroup) {
    const oldName = editingGroup;
    const oldSafe = safeEscapeSelector(oldName);

    const containers = Array.from(document.querySelectorAll(`.group-container[data-name="${oldSafe}"]`));

    containers.forEach(container => {
      container.dataset.name = name;
      const header = container.querySelector('.group-header');
      if (header) {
        header.style.backgroundColor = color;
        const label = header.querySelector('.group-header-left span');
        if (label) label.textContent = name;
      }

      const editBtn = container.querySelector('.group-menu-content div:first-child');
      const deleteBtn = container.querySelector('.group-menu-content div:last-child');
      if (editBtn) editBtn.setAttribute('onclick', `openEditGroupModal('${name}')`);
      if (deleteBtn) deleteBtn.setAttribute('onclick', `openDeleteGroupModal('${name}')`);
    });

    document.querySelectorAll(`.task[data-group="${oldSafe}"]`).forEach(task => {
      task.dataset.group = name;
      refreshTaskUI(task);
    });

    document.querySelectorAll(`.group-container[data-parent="${oldSafe}"]`).forEach(gc => {
      gc.dataset.parent = name;
    });

    delete groups[oldName];
    groups[name] = color;

    rebuildGroupSelects();

    containers.forEach(container => {
      let desiredParent = parentName;
      if (desiredParent && desiredParent === oldName) desiredParent = name;

      const quadrant = container.closest('.quadrant');
      if (!quadrant) return;

      if (desiredParent && groups[desiredParent]) {
        const parentSafe = safeEscapeSelector(desiredParent);
        let parentContainer = quadrant.querySelector(`.group-container[data-name="${parentSafe}"]`);
        if (!parentContainer) {
          parentContainer = createGroupContainer(desiredParent, quadrant, '');
        }

        if (isInside(parentContainer, container)) {
          return;
        }

        container.dataset.parent = desiredParent;
        getGroupContent(parentContainer).appendChild(container);
      } else {
        container.dataset.parent = '';
        quadrant.appendChild(container);
      }
    });

    editingGroup = name;
  } else {
    groups[name] = color;
    rebuildGroupSelects();

    if (parentName && groups[parentName]) {
      const parentSafe = safeEscapeSelector(parentName);

      let parentContainer = document.querySelector(`.group-container[data-name="${parentSafe}"]`);

      if (!parentContainer) {
        const q2 = document.getElementById('q2');
        if (q2) {
          parentContainer = createGroupContainer(parentName, q2, '');
        }
      }

      if (parentContainer) {
        const parentContent = getGroupContent(parentContainer);
        createGroupContainer(name, parentContent, parentName);
      }
    }
  }

  saveToStorage();
  closeGroupModal();
}

function openEditGroupModal(groupName) {
  editingGroup = groupName;
  document.getElementById('groupModalTitle').textContent = 'Edit Group';
  document.getElementById('groupName').value = groupName;
  document.getElementById('groupColor').value = groups[groupName] || '#1976d2';

  rebuildGroupSelects();
  const safe = safeEscapeSelector(groupName);
  const firstInstance = document.querySelector(`.group-container[data-name="${safe}"]`);
  const currentParent = firstInstance ? (firstInstance.dataset.parent || '') : '';

  const parentSelect = document.getElementById('groupParent');
  if (parentSelect) {
    Array.from(parentSelect.options).forEach(opt => {
      if (opt.value === groupName) opt.remove();
    });
    parentSelect.value = currentParent;
  }

  document.getElementById('saveGroupBtn').textContent = 'Save Changes';
  document.getElementById('groupModal').style.display = 'flex';
  document.querySelectorAll('.group-menu-content').forEach(m => m.style.display = 'none');
}

function openDeleteGroupModal(groupName) {
  deletingGroup = groupName;
  document.getElementById('deleteGroupName').textContent = groupName;
  document.getElementById('deleteGroupModal').style.display = 'flex';
  document.querySelectorAll('.group-menu-content').forEach(m => m.style.display = 'none');
}

function closeDeleteGroupModal() {
  deletingGroup = null;
  document.getElementById('deleteGroupModal').style.display = 'none';
}

function confirmDeleteGroup() {
  if (!deletingGroup) return;

  const deleteOption = document.querySelector('input[name="deleteOption"]:checked').value;
  const groupName = deletingGroup;
  const safe = safeEscapeSelector(groupName);

  document.querySelectorAll(`.group-container[data-name="${safe}"]`).forEach(groupContainer => {
    const parentContent = groupContainer.parentElement;
    const parentGroupContainer = parentContent.closest('.group-container');
    const parentGroupName = parentGroupContainer ? parentGroupContainer.dataset.name : '';

    const content = getGroupContent(groupContainer);

    if (deleteOption === 'deleteTasks') {
      groupContainer.remove();
      if (parentGroupContainer) cleanupEmptyGroupChain(parentGroupContainer);
      return;
    }

    if (content) {
      Array.from(content.children).forEach(child => {
        if (child.classList.contains('task')) {
          child.dataset.group = parentGroupName || '';
          refreshTaskUI(child);
        } else if (child.classList.contains('group-container')) {
          child.dataset.parent = parentGroupName || '';
        }
        parentContent.appendChild(child);
      });
    }

    groupContainer.remove();
    if (parentGroupContainer) cleanupEmptyGroupChain(parentGroupContainer);
  });

  delete groups[groupName];

  const groupOption = document.querySelector(`#taskGroup option[value="${safe}"]`);
  if (groupOption) groupOption.remove();

  const parentOption = document.querySelector(`#groupParent option[value="${safe}"]`);
  if (parentOption) parentOption.remove();

  saveToStorage();
  closeDeleteGroupModal();
}

// ============================================
// DRAG AND DROP
// Rules you asked for:
//  - Dragging must NOT change group membership.
//  - Tasks cannot be dropped into groups.
//  - Groups cannot be dropped into groups (nesting only via Edit Group).
//  - Child groups cannot be dragged.
// ============================================

function mergeGroupContents(fromGroupContainer, intoGroupContainer) {
  const fromContent = getGroupContent(fromGroupContainer);
  const intoContent = getGroupContent(intoGroupContainer);
  if (!fromContent || !intoContent) return;

  Array.from(fromContent.children).forEach(child => intoContent.appendChild(child));
}

function setupDropTarget(targetEl, targetInfo) {
  targetEl.addEventListener('dragover', (e) => e.preventDefault());

  targetEl.addEventListener('drop', (e) => {
    e.preventDefault();

    const dragged = document.querySelector('.dragging');
    if (!dragged) return;

    // Close menus
    document.querySelectorAll('.menu').forEach(m => m.style.display = 'none');
    document.querySelectorAll('.group-menu-content').forEach(m => m.style.display = 'none');

    const targetContainer = targetEl;

    // ---- GROUP DROP ----
    if (dragged.classList.contains('group-container')) {
      dragged.classList.remove('dragging');

      // No dropping groups into groups.
      if (targetInfo.type === 'group') {
        return;
      }

      const quadrantEl = targetContainer;
      const groupName = dragged.dataset.name;

      // Membership must NOT change by dragging.
      // Keep its parent chain (if any) and place it under the same parent in the target quadrant.
      const chain = getGroupChainByName(groupName); // outer -> ... -> groupName
      const parentChain = chain.slice(0, -1);       // outer -> ... -> parent
      const parentName = parentChain.length ? parentChain[parentChain.length - 1] : '';

      let destinationParentEl = quadrantEl; // quadrant root by default

      if (parentChain.length) {
        const parentContainer = ensureGroupChainInQuadrant(quadrantEl, parentChain);
        if (parentContainer) {
          destinationParentEl = getGroupContent(parentContainer);
        }
      }

      // Ensure dragged keeps its parent value
      dragged.dataset.parent = parentName;

      // If same group already exists in destination, merge (avoid duplicates)
      const safe = safeEscapeSelector(groupName);
      const existing = destinationParentEl.querySelector(`:scope > .group-container[data-name="${safe}"]`);
      if (existing && existing !== dragged) {
        mergeGroupContents(dragged, existing);
        dragged.remove();
        saveToStorage();
        return;
      }

      destinationParentEl.appendChild(dragged);
      saveToStorage();
      return;
    }

    // ---- TASK DROP ----
    if (dragged.classList.contains('task')) {
      const sourceGroup = dragged.closest('.group-container');
      dragged.classList.remove('dragging');

      // No dropping tasks into groups.
      if (targetInfo.type === 'group') {
        return;
      }

      const quadrantEl = targetContainer;

      // If task is inside a group chain, preserve the chain in the new quadrant
      if (sourceGroup) {
        const chain = getGroupChainFromElement(dragged);
        const innermost = ensureGroupChainInQuadrant(quadrantEl, chain);

        if (innermost) {
          // Keep task's direct group membership
          dragged.dataset.group = chain[chain.length - 1] || dragged.dataset.group || '';
          refreshTaskUI(dragged);
          getGroupContent(innermost).appendChild(dragged);
        } else {
          // Fallback: move without changing membership
          refreshTaskUI(dragged);
          quadrantEl.appendChild(dragged);
        }

        // Remove empty shells in the source quadrant
        cleanupEmptyGroupChain(sourceGroup);
      } else {
        // Ungrouped task moves freely
        dragged.dataset.group = '';
        refreshTaskUI(dragged);
        quadrantEl.appendChild(dragged);
      }

      saveToStorage();
      return;
    }
  });
}

// Make quadrants droppable targets
document.querySelectorAll('.quadrant').forEach(q => {
  setupDropTarget(q, { type: 'quadrant', quadrantId: q.id });
});

// ============================================
// UI UTILITIES
// ============================================
function toggleSyncOptions() {
  document.getElementById('syncOptions').classList.toggle('show');
}

function closeSyncOptions() {
  document.getElementById('syncOptions').classList.remove('show');
}

document.addEventListener('click', (e) => {
  if (!e.target.closest('.sync-container')) {
    closeSyncOptions();
  }
});

function updateSyncStatus(status) {
  const el = document.getElementById('syncStatus');
  el.textContent = status;
  el.className = 'sync-status';

  if (status.includes('Syncing') || status.includes('Loading')) {
    el.classList.add('syncing');
  } else if (status.includes('Synced') || status.includes('Loaded') || status === 'Online') {
    el.classList.add('online');
  } else {
    el.classList.add('offline');
  }
}

function formatTime(date) {
  if (!date) return '';
  const now = new Date();
  const diff = now - date;
  const minutes = Math.floor(diff / 60000);

  if (minutes < 1) return 'just now';
  if (minutes === 1) return '1 min ago';
  if (minutes < 60) return `${minutes} mins ago`;

  const hours = Math.floor(minutes / 60);
  if (hours === 1) return '1 hour ago';
  if (hours < 24) return `${hours} hours ago`;

  const days = Math.floor(hours / 24);
  if (days === 1) return 'yesterday';
  return `${days} days ago`;
}

function clearAllData() {
  if (confirm('Clear all data?')) {
    localStorage.removeItem(STORAGE_KEY);
    clearCurrentData();
    groups = {};

    const taskSel = document.getElementById('taskGroup');
    if (taskSel) taskSel.innerHTML = '<option value="">No Group</option>';

    const parentSel = document.getElementById('groupParent');
    if (parentSel) parentSel.innerHTML = '<option value="">No Parent</option>';
  }
}

// ============================================
// SELF-TESTS (lightweight)
// ============================================
function assert(condition, message) {
  if (!condition) throw new Error('Test failed: ' + message);
}

function runSelfTests() {
  // Test 1: safeEscapeSelector escapes special chars
  const escaped = safeEscapeSelector('A B');
  assert(typeof escaped === 'string' && escaped.length > 0, 'safeEscapeSelector returns string');

  // Test 2: getQuadrantFromImportantUrgent mapping
  assert(getQuadrantFromImportantUrgent(true, true) === 'q1', 'Quadrant q1');
  assert(getQuadrantFromImportantUrgent(true, false) === 'q2', 'Quadrant q2');
  assert(getQuadrantFromImportantUrgent(false, true) === 'q3', 'Quadrant q3');
  assert(getQuadrantFromImportantUrgent(false, false) === 'q4', 'Quadrant q4');

  console.log('Self-tests passed');
}

// ============================================
// STARTUP
// ============================================
document.addEventListener('DOMContentLoaded', () => {
  initGoogleAuth();

  // Load from localStorage
  const savedData = localStorage.getItem(STORAGE_KEY);
  if (savedData) {
    try {
      const data = JSON.parse(savedData);
      loadData(data);
    } catch (e) {
      console.error('Error loading saved data:', e);
    }
  }

  // Check last sync time
  const lastSync = localStorage.getItem('lastSyncTime');
  if (lastSync) {
    lastSyncTime = new Date(lastSync);
    updateSyncStatus(`Last sync: ${formatTime(lastSyncTime)}`);
  }

  // Tests
  try {
    runSelfTests();
  } catch (err) {
    console.error(err);
  }
});
</script>
</body>
</html>
